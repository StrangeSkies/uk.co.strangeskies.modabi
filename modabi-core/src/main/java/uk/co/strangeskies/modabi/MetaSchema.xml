<?xml version="1.1"?>
<modelSchema xmlns="modabi.strangeskies.co.uk">

	<dependencies>
		<dependency id="baseSchema" />
	</dependencies>

	<types>
		<type name="model" dataClass=":model.ModelNode" source="mockingReference"
			domain="model" />
		<type name="models" source="set" elementType="model" />
	</types>

	<models>
		<model id="typeBase" dataClass=":model.data.DataType">
			<property id="name" />
			<property id="dataClass" type="class" />
			<element id="restrictions" occurances="0..1">
				<element id="restriction" occurances="0..">
				</element>
			</element>
			<element id="properties" occurances="0..1">
				<element id="property" baseModel="property" occurances="0.." />
			</element>
		</model>

		<model id="type" baseModel="typeBase" dataClass=":model.data.DataType">
			<element id="baseType" baseModel="base" />
		</model>

		<model id="node" dataClass=":model.SchemaNode" abstract="true">
			<simpleElement id="documentation" type="html" />
			<property id="id" optional="true" type="string" />
		</model>

		<model id="optional" baseModel="node" abstract="true">
			<documentation>
				Required nodes cannot be overridden by optional nodes
				in deriving models. They also cannot be overridden by hidden nodes
				unless a default value is provided.
			</documentation>
			<property id="include" type="enum" optional="true"
				enumClass=":model:modelInclusion">
			</property>
		</model>

		<model id="provision" dataClass=":model.ProviderNode" abstract="true">
			<property id="providedClass" type="class" />
			<property id="providerOutMethod" type="string" />
			<property id="provideMethod" optional="true" type="string" />
			<element id="provides" inMethod="addProvision" outMethod="getProvisions"
				outMethodIterable="true" baseModel="provision" occurrences="0.." />
		</model>

		<model id="input" baseModel="node">
			<property id="inMethod" optional="true" />
			<property id="inMethodChained" optional="true" type="boolean" />
		</model>

		<model id="data" baseModel="input">
			<property id="outMethod" optional="true" />
			<property id="outMethodIterable" type="boolean" optional="true" />
			<property id="dataClass" type="class" optional="true" />
		</model>

		<model id="branch" baseModel="node" dataClass=":model.BranchingNode">
			<provides providerOutMethod="addChild">
				<provides providedClass=":model.ElementNode"
					providerOutMethod="element" />
				<provides providedClass=":model.SequenceNode"
					providerOutMethod="sequence" />
				<provides providedClass=":model.ChoiceNode"
					providerOutMethod="choice" />
				<provides providedClass=":model.PropertyNode"
					providerOutMethod="property" />
				<provides providedClass=":model.DataNode"
					providerOutMethod="data" />
			</provides>

			<element id="child" outMethod="getChildren"
				outMethodIterable="true" baseModel="node" occurrences="0.." />
		</model>

		<model id="choice" baseModel="branch, input" dataClass=":model.ChoiceNode"
			builderClass=":model.builder.choiceNodeBuilder" abstract="false">
			<property id="mandatory" type="boolean" />
			<element id="child" occurrences="2.." />
		</model>

		<model id="sequence" baseModel="branch, input, optional"
			dataClass=":model.SequenceNode" builderClass=":model.builder.SequenceNodeBuilder"
			abstract="false">
			<property id="inMethodParameters" optional="true" type="classes" />
		</model>

		<model id="repeatable" baseModel="node">
			<property id="occurances" type="integerRange" optional="true" />
		</model>

		<model id="model" baseModel="branch" dataClass=":model.ModelNode">
			<element id="provides" inMethod="addProvision" outMethod="getProvisions"
				outMethodIterable="true" baseModel="provision" occurrences="0.." />
			<property id="id" optional="false" />
			<property id="abstract" inMethod="isAbstract" type="boolean"
				optional="true" />
			<choice id="model" mandatory="false">
				<documentation>
					The model which this model is based on. The children
					of the models will aggregate in the order they appear in this list,
					and the id of this model can be inserted to specify the position
					its own children will occur. This model must specify a dataClass
					which is covariant with the dataType of each model in this list.

					Using 'adaptionModel' doesn't require covariant dataClass like a
					'baseModel'
				</documentation>
				<property id="baseModel" type="models" />
				<property id="adaptionModel" type="model" />
			</choice>
			<property id="bindingStrategy" type="enum" enumClass=":model.BindingStrategy"
				optional="true" />
			<property id="dataClass" type="class" />
			<property id="builderClass" optional="true" type="class" />
			<property id="buildMethod" optional="true" type="string" />
			<element id="child" />
		</model>

		<model id="element" dataClass=":model.ElementNode" builderClass=":model.ElementNodeBuilder"
			baseModel="data, repeatable, model" abstract="false" />

		<model id="typedData" baseModel="data">
			<property id="type" type="dataType" />
			<simpleElement id="value" type="data" />
		</model>

		<model id="simpleElement" baseModel="typedData, 
				repeatable"
			abstract="false" dataClass=":model.DataNode" builderClass="node.builder.DataNodeBuilder">
			<property id="id" optional="false" />
		</model>

		<model id="content" baseModel="typedData, optional" abstract="false"
			dataClass=":model.DataNode" builderClass="node.builder.DataNodeBuilder" />

		<model id="property" baseModel="content" dataClass=":model.PropertyNode"
			builderClass="node.builder.PropertyNodeBuilder" abstract="false">
			<property id="id" optional="false" />
		</model>

		<model id="problem" baseModel="node" builderClass="?.ProblemConditionBuilder">
			<element id="condition" model="condition" />
		</model>
		<model id="warning" baseModel="problem" builderClass="?.WarningConditionBuilder"
			abstract="false" />
		<model id="exception" baseModel="problem" builderClass="?.ExceptionConditionBuilder"
			abstract="false" />
		<model id="error" baseModel="problem" builderClass="?.ErrorConditionBuilder"
			abstract="false" />

		<model id="modelSchema" dataClass=":SchemaGraph" builderClass=":SchemaGraphBuilder">
			<!-- The namespace this schema belongs to. (Assumed default namespace 
				if omitted.) -->
			<property id="namespace" inMethod="namespace" outMethod="getNamespace"
				optional="true" />
			<element id="dependencies" occurrences="0..1" dataClass=":SchemaDependencies">
				<element id="dependency" baseModel="include" dataClass=":SchemaGraph"
					occurrences="0.." />
			</element>
			<element id="requiredClasses" occurrences="0..1">
				<element id="requirement" dataClass="java.lang.Class"
					occurrences="0..">
					<property id="class" type="class" />
					<property id="optional" type="boolean" />
					<property id="singleton" type="boolean" />
					<element id="provides" baseModel="provision" occurences="0.." />
				</element>
			</element>
			<element id="types" occurrences="0..1">
				<element baseModel="type" occurrences="0.." outIterator="getTypes" />
			</element>
			<element id="models" occurrences="0..1">
				<element id="model" adaptionModel="model" occurrences="0.."
					abstract="false" adaptionTargetClass=":model.SchemaNode"
					outMethodIterable="true">
					<sequence inMethod="create" inMethodChained="true" />
				</element>
			</element>
		</model>
	</models>
</modelSchema>
